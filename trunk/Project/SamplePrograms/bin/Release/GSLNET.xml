<?xml version="1.0"?>
<doc>
    <assembly>
        "GSLNET"
    </assembly>
    <members>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.IntermediateOutput">
            <summary>途中経過書き出し処理</summary>
        </member>
        <member name="M:GSLNET.OrdinaryDifferentialEquations.Solve(GSLNET.GSLFunctions.TDArrayToDArray,System.Double@,System.Double,System.Double@,System.Double[]@,System.Int32@)">
            <summary>初期値問題を解く</summary>
            <param name="eFnc">微分値計算関数</param>
            <param name="initialTime">初期時刻</param>
            <param name="endTime">最終時刻</param>
            <param name="initialTStep">初期ΔT</param>
            <param name="variables">状態変数初期値</param>
        </member>
        <member name="M:GSLNET.OrdinaryDifferentialEquations.SetScaledControl(System.Double,System.Double,System.Double,System.Double,System.Double[])">
            <summary>スケーリングつきのステップ幅調整関数を設定する</summary>
            <param name="eps_abs">絶対誤差</param>
            <param name="eps_rel">相対誤差</param>
            <param name="a_y">解y(t)に対するスケーリング係数</param>
            <param name="a_dydt">導関数y'(t)に対するスケーリング係数</param>
            <param name="scale">各要素に対するスケーリング配列</param>
        </member>
        <member name="M:GSLNET.OrdinaryDifferentialEquations.SetYPControl(System.Double,System.Double)">
            <summary>解の微分値に対する誤差に基づいてステップ幅調整を行うように設定する</summary>
            <param name="eps_abs">絶対誤差</param>
            <param name="eps_rel">相対誤差</param>
        </member>
        <member name="M:GSLNET.OrdinaryDifferentialEquations.SetYControl(System.Double,System.Double)">
            <summary>解の値に対する誤差に基づいてステップ幅調整を行うように設定する</summary>
            <param name="eps_abs">絶対誤差</param>
            <param name="eps_rel">相対誤差</param>
        </member>
        <member name="M:GSLNET.OrdinaryDifferentialEquations.SetStandardControl(System.Double,System.Double,System.Double,System.Double)">
            <summary>標準のステップ幅調整関数を設定する</summary>
            <param name="eps_abs">絶対誤差</param>
            <param name="eps_rel">相対誤差</param>
            <param name="a_y">解y(t)に対するスケーリング係数</param>
            <param name="a_dydt">導関数y'(t)に対するスケーリング係数</param>
        </member>
        <member name="P:GSLNET.OrdinaryDifferentialEquations.Solver">
            <summary>常微分方程式の解法の種類を取得する</summary>
        </member>
        <member name="M:GSLNET.OrdinaryDifferentialEquations.#ctor(GSLNET.OrdinaryDifferentialEquations.SolverType,System.Int32)">
            <summary>コンストラクタ</summary>
            <param name="sType">常微分方程式の解法の種類</param>
            <param name="dimension">次数</param>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.ImplicitGear2">
            <summary>M=2の陰的ギア法</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.ImplicitGear1">
            <summary>M=1の陰的ギア法</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.BulirschStoer">
            <summary>陰的ブリルシュ・ストア法</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.ImplicitRungeKutta4">
            <summary>四次の陰的ルンゲ・クッタ法</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.ImplicitRungeKutta2">
            <summary>二次の陰的ルンゲ・クッタ法</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.RungeKuttaPrinceDormand">
            <summary>埋め込み型RKPD89公式</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.RungeKuttCashKarp">
            <summary>埋め込み型RKCK45公式</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.RungeKuttaFehlberg">
            <summary>埋め込み型RKF45公式</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.RungeKutta4">
            <summary>四次のルンゲ・クッタ法</summary>
        </member>
        <member name="F:GSLNET.OrdinaryDifferentialEquations.SolverType.RungeKutta2">
            <summary>埋め込み型RK23公式</summary>
        </member>
        <member name="T:GSLNET.OrdinaryDifferentialEquations.SolverType">
            <summary>常微分方程式の解法の種類</summary>
        </member>
        <member name="M:GSLNET.Minimization.Iteration">
            <summary>反復計算回数を取得する</summary>
        </member>
        <member name="M:GSLNET.Minimization.Solve(GSLNET.GSLFunctions.DToD,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Double@)">
            <summary>反復計算によってf(x)が最小化するxを求める</summary>
            <param name="minimizeFunction">最小化する関数f(x)</param>
            <param name="lowerX">x下限</param>
            <param name="upperX">x上限</param>
            <param name="epsAbs">絶対誤差</param>
            <param name="epsRel">相対誤差</param>
            <param name="maxIter">最大反復回数</param>
            <param name="xValue">xの初期値</param>
        </member>
        <member name="M:GSLNET.Minimization.#ctor(GSLNET.Minimization.SolverType)">
            <summary>コンストラクタ</summary>
            <param name="sType">一次元関数最適化法の種類</param>
        </member>
        <member name="F:GSLNET.Minimization.SolverType.Brent">
            <summary>Brent法</summary>
        </member>
        <member name="F:GSLNET.Minimization.SolverType.GoldenSection">
            <summary>黄金探索法</summary>
        </member>
        <member name="T:GSLNET.Minimization.SolverType">
            <summary>一次元関数最適化法の種類</summary>
        </member>
        <member name="T:GSLNET.Minimization">
            <summary>一次元関数最適化クラス</summary>
        </member>
        <member name="M:GSLNET.Blas.DGemv(GSLNET.Blas.TransposeType,System.Double,GSLNET.MatrixView,GSLNET.VectorView,System.Double,GSLNET.VectorView@)">
            <summary>行列とベクトルの積と和を計算する（y = α op(A) x + βy）</summary>
            <param name="transA">行列Aの転置状態</param>
            <param name="alpha">第一項の係数</param>
            <param name="mA">行列A</param>
            <param name="vX">ベクトルX</param>
            <param name="beta">第二項の係数</param>
            <param name="vY">ベクトルY（解が上書きされる）</param>
        </member>
        <member name="M:GSLNET.Blas.DGemv(GSLNET.Blas.TransposeType,System.Double,GSLNET.Matrix!System.Runtime.CompilerServices.IsConst,GSLNET.Vector!System.Runtime.CompilerServices.IsConst,System.Double,GSLNET.Vector@)">
            <summary>行列とベクトルの積と和を計算する（y = α op(A) x + βy）</summary>
            <param name="transA">行列Aの転置状態</param>
            <param name="alpha">第一項の係数</param>
            <param name="mA">行列A</param>
            <param name="vX">ベクトルX</param>
            <param name="beta">第二項の係数</param>
            <param name="vY">ベクトルY（解が上書きされる）</param>
        </member>
        <member name="M:GSLNET.Blas.DGemm(GSLNET.Blas.TransposeType,GSLNET.Blas.TransposeType,System.Double,GSLNET.MatrixView,GSLNET.MatrixView,System.Double,GSLNET.MatrixView@)">
            <summary>行列と行列の積と和を計算する（C = α op(A) op(B) + βC）</summary>
            <param name="transA">行列Aの転置状態</param>
            <param name="transB">行列Bの転置状態</param>
            <param name="alpha">第一項の係数</param>
            <param name="mA">行列A</param>
            <param name="mB">行列B</param>
            <param name="beta">第二項の係数</param>
            <param name="mC">行列C（解が上書きされる）</param>
        </member>
        <member name="M:GSLNET.Blas.DGemm(GSLNET.Blas.TransposeType,GSLNET.Blas.TransposeType,System.Double,GSLNET.Matrix!System.Runtime.CompilerServices.IsConst,GSLNET.Matrix!System.Runtime.CompilerServices.IsConst,System.Double,GSLNET.Matrix@)">
            <summary>行列と行列の積と和を計算する（C = α op(A) op(B) + βC）</summary>
            <param name="transA">行列Aの転置状態</param>
            <param name="transB">行列Bの転置状態</param>
            <param name="alpha">第一項の係数</param>
            <param name="mA">行列A</param>
            <param name="mB">行列B</param>
            <param name="beta">第二項の係数</param>
            <param name="mC">行列C（解が上書きされる）</param>
        </member>
        <member name="F:GSLNET.Blas.TransposeType.ConjugateTranspose">
            <summary>共役転置行列</summary>
        </member>
        <member name="F:GSLNET.Blas.TransposeType.TransPose">
            <summary>転置行列</summary>
        </member>
        <member name="F:GSLNET.Blas.TransposeType.NoTranspose">
            <summary>転置無し</summary>
        </member>
        <member name="T:GSLNET.Blas.TransposeType">
            <summary>転置の種類</summary>
        </member>
        <member name="M:GSLNET.Root.Iteration">
            <summary>反復計算回数を取得する</summary>
        </member>
        <member name="M:GSLNET.Root.Solve(GSLNET.GSLFunctions.DToD,System.Double,System.Double,System.Int32,System.Double@)">
            <summary>反復計算によってf(x)=0となるxを求める</summary>
            <param name="eFnc">関数f(x)</param>
            <param name="lowerX">探索範囲下限</param>
            <param name="upperX">探索範囲上限</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="xValue">解</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.Root.#ctor(GSLNET.Root.SolverType)">
            <summary>コンストラクタ</summary>
            <param name="sType">解法の種類</param>
        </member>
        <member name="F:GSLNET.Root.AbsoluteError">
            <summary>絶対誤差を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.Root.RelativeError">
            <summary>相対誤差を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.Root.ConvergenceType">
            <summary>収束判定基準を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.Root.Convergence.Delta">
            <summary>変化量の収束：|x1-x0| ＜ epsabs + epsrel |x1|</summary>
        </member>
        <member name="F:GSLNET.Root.Convergence.Interval">
            <summary>区間の収束：|a-b| ＜ epsabs + epsrel min(|a|,|b|)</summary>
        </member>
        <member name="F:GSLNET.Root.Convergence.Residual">
            <summary>残差の収束：|f| ＜ epsabs</summary>
        </member>
        <member name="T:GSLNET.Root.Convergence">
            <summary>収束判定基準</summary>
        </member>
        <member name="F:GSLNET.Root.SolverType.BrentDekker">
            <summary>ブレント法</summary>
        </member>
        <member name="F:GSLNET.Root.SolverType.FalsePosition">
            <summary>失敗点法</summary>
        </member>
        <member name="F:GSLNET.Root.SolverType.Bisection">
            <summary>二分法</summary>
        </member>
        <member name="T:GSLNET.Root.SolverType">
            <summary>解法の種類</summary>
        </member>
        <member name="M:GSLNET.VectorView.GetValue(System.UInt32)">
            <summary>要素の値を取得する</summary>
            <param name="index">要素番号</param>
            <returns>要素の値</returns>
        </member>
        <member name="M:GSLNET.VectorView.SetValue(System.UInt32,System.Double)">
            <summary>要素に値を設定する</summary>
            <param name="index">要素番号</param>
            <param name="value">設定する実数値</param>
        </member>
        <member name="M:GSLNET.VectorView.Initialize(GSLNET.Vector,System.UInt32,System.UInt32)">
            <summary>初期化する</summary>
            <param name="index">要素番号</param>
            <param name="size">要素数</param>
        </member>
        <member name="M:GSLNET.VectorView.#ctor(GSLNET.Vector,System.UInt32,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="index">要素番号</param>
            <param name="size">要素数</param>
        </member>
        <member name="P:GSLNET.VectorView.Size">
            <summary>要素数を取得する</summary>
        </member>
        <member name="P:GSLNET.VectorView.Index">
            <summary>要素番号を取得する</summary>
        </member>
        <member name="M:GSLNET.LinearAlgebra.QRSolve(GSLNET.Matrix,GSLNET.Vector,GSLNET.Vector@)">
            <summary>QR分解結果を利用してAx=bを解く</summary>
            <param name="qr">QR分解行列</param>
            <param name="tau">ハウスホルダーベクトル</param>
            <param name="x">ベクトルb（解で上書きされる）</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.QRSolve(GSLNET.Matrix,GSLNET.Vector,GSLNET.Vector,GSLNET.Vector@)">
            <summary>QR分解結果を利用してAx=bを解く</summary>
            <param name="qr">QR分解行列</param>
            <param name="tau">ハウスホルダーベクトル</param>
            <param name="b">ベクトルb</param>
            <param name="x">解</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.QRDecomposition(GSLNET.Matrix@,GSLNET.Vector@)">
            <summary>QR分解を行う</summary>
            <param name="matrix">行列</param>
            <param name="tau">ハウスホルダーベクトル</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.LUInvert(GSLNET.MatrixView,GSLNET.Permutation,GSLNET.MatrixView@)">
            <summary>LU分解結果を利用して逆行列を求める</summary>
            <param name="lu">LU分解行列</param>
            <param name="permutation">置換ベクトル</param>
            <param name="inverse">逆行列</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.LUInvert(GSLNET.Matrix,GSLNET.Permutation,GSLNET.Matrix@)">
            <summary>LU分解結果を利用して逆行列を求める</summary>
            <param name="lu">LU分解行列</param>
            <param name="permutation">置換ベクトル</param>
            <param name="inverse">逆行列</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.LUSolve(GSLNET.Matrix,GSLNET.Permutation,GSLNET.Vector@)">
            <summary>LU分解結果を利用してAx=bを解く</summary>
            <param name="lu">LU分解行列</param>
            <param name="permutation">置換ベクトル</param>
            <param name="x">ベクトルb（解で上書きされる）</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.LUSolve(GSLNET.Matrix,GSLNET.Permutation,GSLNET.Vector,GSLNET.Vector@)">
            <summary>LU分解結果を利用してAx=bを解く</summary>
            <param name="lu">LU分解行列</param>
            <param name="permutation">置換ベクトル</param>
            <param name="b">ベクトルb</param>
            <param name="x">解</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.LUDecomposition(GSLNET.MatrixView@,GSLNET.Permutation@,System.Int32@)">
            <summary>LU分解を行う</summary>
            <param name="matrixView">行列</param>
            <param name="permutation">置換ベクトル</param>
            <param name="signum">置換の符号（(-1)^n）</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.LinearAlgebra.LUDecomposition(GSLNET.Matrix@,GSLNET.Permutation@,System.Int32@)">
            <summary>LU分解を行う</summary>
            <param name="matrix">行列</param>
            <param name="permutation">置換ベクトル</param>
            <param name="signum">置換の符号（(-1)^n）</param>
            <returns>エラーコード</returns>
        </member>
        <member name="T:GSLNET.LinearAlgebra">
            <summary>線形代数計算クラス</summary>
        </member>
        <member name="M:GSLNET.MatrixView.SetValue(System.UInt32,System.UInt32,System.Double)">
            <summary>行列成分を設定する</summary>
            <param name="rowIndex">行番号</param>
            <param name="columnIndex">列番号</param>
            <param name="value">行列成分(rowIndex, columnIndex)の値</param>
        </member>
        <member name="M:GSLNET.MatrixView.GetValue(System.UInt32,System.UInt32)">
            <summary>行列成分を取得する</summary>
            <param name="rowIndex">行番号</param>
            <param name="columnIndex">列番号</param>
            <returns>行列成分(rowIndex, columnIndex)の値</returns>
        </member>
        <member name="M:GSLNET.MatrixView.Initialize(GSLNET.Matrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>初期化する</summary>
            <param name="columnIndex">行番号</param>
            <param name="rowIndex">列番号</param>
            <param name="columnSize">行数</param>
            <param name="rowSize">列数</param>
        </member>
        <member name="M:GSLNET.MatrixView.#ctor(GSLNET.Matrix,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="columnIndex">行番号</param>
            <param name="rowIndex">列番号</param>
            <param name="columnSize">行数</param>
            <param name="rowSize">列数</param>
        </member>
        <member name="P:GSLNET.MatrixView.RowSize">
            <summary>列数を取得する</summary>
        </member>
        <member name="P:GSLNET.MatrixView.ColumnSize">
            <summary>行数を取得する</summary>
        </member>
        <member name="P:GSLNET.MatrixView.RowIndex">
            <summary>列番号を取得する</summary>
        </member>
        <member name="P:GSLNET.MatrixView.ColumnIndex">
            <summary>行番号を取得する</summary>
        </member>
        <member name="M:GSLNET.MultiRoot.Solve(GSLNET.GSLFunctions.DArrayToDArray,System.Double[]@,System.Double,System.Int32,System.Int32@)">
            <summary>反復計算によって根を求める</summary>
            <param name="initialX">探索開始点</param>
            <param name="epsabs">絶対誤差</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="iterNum">反復回数</param>
            <remarks>関数出力f(x)と絶対誤差によって収束を判定する</remarks>
        </member>
        <member name="M:GSLNET.MultiRoot.Solve(GSLNET.GSLFunctions.DArrayToDArray,System.Double[]@,System.Double,System.Double,System.Int32,System.Int32@)">
            <summary>反復計算によって根を求める</summary>
            <param name="initialX">探索開始点</param>
            <param name="epsabs">絶対誤差</param>
            <param name="epsrel">相対誤差</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="iterNum">反復回数</param>
            <remarks>ステップ幅と探索点を、絶対誤差および相対誤差を使って比較し、収束を判定する</remarks>
        </member>
        <member name="M:GSLNET.MultiRoot.GetDx">
            <summary>直前に取ったステップ幅dXを返す</summary>
        </member>
        <member name="M:GSLNET.MultiRoot.GetOutputs">
            <summary>現時点の関数値f(x)を返す</summary>
        </member>
        <member name="M:GSLNET.MultiRoot.GetRoots">
            <summary>現時点の解を返す</summary>
        </member>
        <member name="M:GSLNET.MultiRoot.#ctor(GSLNET.MultiRoot.SolverType,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="type">多次元関数求根法の種類</param>
            <param name="n">次元数</param>
        </member>
        <member name="F:GSLNET.MultiRoot.SolverType.Broyden">
            <summary>ブロイデン法</summary>
        </member>
        <member name="F:GSLNET.MultiRoot.SolverType.Newton">
            <summary>ニュートン・ラプソン法</summary>
        </member>
        <member name="F:GSLNET.MultiRoot.SolverType.Hybrid">
            <summary>パウエルの修正組み合わせ法</summary>
        </member>
        <member name="F:GSLNET.MultiRoot.SolverType.ScalingHybrid">
            <summary>スケーリング付のパウエルの修正組み合わせ法</summary>
        </member>
        <member name="T:GSLNET.MultiRoot.SolverType">
            <summary>多次元関数求根法の種類</summary>
        </member>
        <member name="T:GSLNET.MultiRoot">
            <summary>多次元関数求根クラス（微分値は有限差分近似する）</summary>
        </member>
        <member name="M:GSLNET.Wavelet.Transform(System.Double[]@,GSLNET.Wavelet.WaveletDirection)">
            <summary>変換処理を行う</summary>
            <param name="data">変換するデータ</param>
            <param name="dir">通常の変換か逆変換か</param>
        </member>
        <member name="M:GSLNET.Wavelet.#ctor(GSLNET.Wavelet.WaveletType,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="wType">ウェーブレットの種類</param>
            <param name="k">ウェーブレット・ファミリーのメンバー</param>
        </member>
        <member name="F:GSLNET.Wavelet.WaveletDirection.Inverse">
            <summary>逆</summary>
        </member>
        <member name="F:GSLNET.Wavelet.WaveletDirection.Forward">
            <summary>順</summary>
        </member>
        <member name="T:GSLNET.Wavelet.WaveletDirection">
            <summary>方向</summary>
        </member>
        <member name="F:GSLNET.Wavelet.WaveletType.BSpline">
            <summary>ベータスプライン・ウェーブレット</summary>
        </member>
        <member name="F:GSLNET.Wavelet.WaveletType.Haar">
            <summary>ハール・ウェーブレット</summary>
        </member>
        <member name="F:GSLNET.Wavelet.WaveletType.Daubechies">
            <summary>ドブシ・ウェーブレット</summary>
        </member>
        <member name="T:GSLNET.Wavelet.WaveletType">
            <summary>ウェーブレットの種類</summary>
        </member>
        <member name="M:GSLNET.RandomDistribution.GaussianPdf(System.Double,System.Double)">
            <summary>標準偏差σの正規分布の確率密度関数の値を返す</summary>
            <param name="x">x</param>
            <param name="sigma">標準偏差</param>
        </member>
        <member name="M:GSLNET.RandomDistribution.Gaussian(GSLNET.RandomDistribution.GaussianGeneratorType,System.Double,GSLNET.Rng)">
            <summary>標準偏差σの正規乱数を返す</summary>
            <param name="gType">正規乱数生成法の種類</param>
            <param name="sigma">標準偏差</param>
            <param name="random">乱数オブジェクト</param>
        </member>
        <member name="F:GSLNET.RandomDistribution.GaussianGeneratorType.Ratio">
            <summary>キンダーマン-モナハン-レバの比による方法</summary>
        </member>
        <member name="F:GSLNET.RandomDistribution.GaussianGeneratorType.Ziggurat">
            <summary>マルサグリア-ツァンのジッグラト</summary>
        </member>
        <member name="F:GSLNET.RandomDistribution.GaussianGeneratorType.BoxMuler">
            <summary>ボックス・ミューラー法</summary>
        </member>
        <member name="T:GSLNET.RandomDistribution.GaussianGeneratorType">
            <summary>正規乱数生成法の種類</summary>
        </member>
        <member name="M:GSLNET.Rng.Uniform">
            <summary>0~1の範囲に一様に分布する乱数を作成する</summary>
        </member>
        <member name="M:GSLNET.Rng.#ctor(GSLNET.Rng.GeneratorType,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>コンストラクタ</summary>
            <param name="gType">乱数生成器の種類</param>
            <param name="s">乱数の種</param>
        </member>
        <member name="M:GSLNET.Rng.#ctor(GSLNET.Rng.GeneratorType)">
            <summary>コンストラクタ</summary>
            <param name="gType">乱数生成器の種類</param>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.Taus2">
            <summary>タウスワース型乱数発生器2</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.Taus">
            <summary>タウスワース型乱数発生器</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.MultipleRecursive">
            <summary>レキュエルの重再起結合乱数発生器（五次）</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.CombinedMultipleRecursive">
            <summary>レキュエルの重再起結合乱数発生器</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.Ranlux389">
            <summary>リュッシャ－の方法</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.Ranlux2">
            <summary>Luxury Random Numbers Level2</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.Ranlux1">
            <summary>Luxury Random Numbers Level1</summary>
        </member>
        <member name="F:GSLNET.Rng.GeneratorType.MT19937">
            <summary>メルセンヌ・ツイスター</summary>
        </member>
        <member name="T:GSLNET.Rng.GeneratorType">
            <summary>乱数生成器の種類</summary>
        </member>
        <member name="M:GSLNET.RootWithDerivative.Solve(GSLNET.GSLFunctions.DToD,GSLNET.GSLFunctions.DToD,System.Int32,System.Double@)">
            <summary>反復計算によってf(x)=0となるxを求める</summary>
            <param name="eFnc">関数f(x)</param>
            <param name="eFncDF">微分値計算関数df(x)</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="xValue">初期値</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.RootWithDerivative.Solve(GSLNET.GSLFunctions.DToD,System.Int32,System.Double@)">
            <summary>反復計算によってf(x)=0となるxを求める</summary>
            <param name="eFnc">関数f(x)</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="xValue">初期値</param>
            <returns>エラーコード</returns>
        </member>
        <member name="M:GSLNET.RootWithDerivative.#ctor(GSLNET.RootWithDerivative.SolverType)">
            <summary>コンストラクタ</summary>
            <param name="sType">解法の種類</param>
        </member>
        <member name="M:GSLNET.RootWithDerivative.Iteration">
            <summary>反復計算回数を取得する</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.DeltaH">
            <summary>微分値径算用差分を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.AbsoluteError">
            <summary>絶対誤差を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.RelativeError">
            <summary>相対誤差を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.ConvergenceType">
            <summary>収束判定基準を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.Convergence.Delta">
            <summary>変化量の収束：|x1-x0| ＜ epsabs + epsrel |x1|</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.Convergence.Residual">
            <summary>残差の収束：|f| ＜ epsabs</summary>
        </member>
        <member name="T:GSLNET.RootWithDerivative.Convergence">
            <summary>収束判定基準</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.SolverType.Steffenson">
            <summary>ステフェンソンの方法</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.SolverType.Secant">
            <summary>割線法</summary>
        </member>
        <member name="F:GSLNET.RootWithDerivative.SolverType.Newton">
            <summary>ニュートン法</summary>
        </member>
        <member name="T:GSLNET.RootWithDerivative.SolverType">
            <summary>解法の種類</summary>
        </member>
        <member name="M:GSLNET.LinearMultiFit.GetParameters(GSLNET.Matrix,GSLNET.Vector,GSLNET.Matrix@,GSLNET.Vector,GSLNET.Vector@,System.Double@)">
            <summary>重回帰係数を求める（重み付き）</summary>
            <param name="xMatrix">独立変数行列</param>
            <param name="yVector">従属変数ベクトル</param>
            <param name="cov">重回帰係数の共分散行列</param>
            <param name="weight">重みベクトル</param>
            <param name="parameters">重回帰係数</param>
            <param name="error">残差二乗和</param>
        </member>
        <member name="M:GSLNET.LinearMultiFit.GetParameters(GSLNET.Matrix,GSLNET.Vector,GSLNET.Matrix@,GSLNET.Vector@,System.Double@)">
            <summary>重回帰係数を求める</summary>
            <param name="xMatrix">独立変数行列</param>
            <param name="yVector">従属変数ベクトル</param>
            <param name="cov">重回帰係数の共分散行列</param>
            <param name="parameters">重回帰係数</param>
            <param name="error">残差二乗和</param>
        </member>
        <member name="M:GSLNET.LinearMultiFit.#ctor(System.UInt32,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="dataNumber">データの数</param>
            <param name="variableNumber">変数の数</param>
        </member>
        <member name="T:GSLNET.LinearMultiFit">
            <summary>重回帰クラス</summary>
        </member>
        <member name="M:GSLNET.Vector.FromArray(System.Double[])">
            <summary>配列を読み込む</summary>
            <param name="arr">配列</param>
        </member>
        <member name="M:GSLNET.Vector.ToArray">
            <summary>配列に変換する</summary>
            <returns>配列</returns>
        </member>
        <member name="M:GSLNET.Vector.CopyTo(GSLNET.Vector@)">
            <summary>ベクトルをコピーする</summary>
            <param name="dest">コピー先のベクトル</param>
        </member>
        <member name="M:GSLNET.Vector.GetValue(System.UInt32)">
            <summary>要素の値を取得する</summary>
            <param name="index">要素番号</param>
            <returns>要素の値</returns>
        </member>
        <member name="M:GSLNET.Vector.SubtractValue(System.UInt32,System.Double)">
            <summary>要素から減算する</summary>
            <param name="index">要素番号</param>
            <param name="value">要素から減算する値</param>
        </member>
        <member name="M:GSLNET.Vector.AddValue(System.UInt32,System.Double)">
            <summary>要素に加算する</summary>
            <param name="index">要素番号</param>
            <param name="value">要素に加算する値</param>
        </member>
        <member name="M:GSLNET.Vector.SetValue(System.Double)">
            <summary>全要素に値を設定する</summary>
            <param name="value">設定する実数値</param>
        </member>
        <member name="M:GSLNET.Vector.SetValue(System.UInt32,System.Double)">
            <summary>要素に値を設定する</summary>
            <param name="index">要素番号</param>
            <param name="value">設定する実数値</param>
        </member>
        <member name="P:GSLNET.Vector.Size">
            <summary>ベクトルのサイズを取得する</summary>
        </member>
        <member name="M:GSLNET.Vector.#ctor(System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="n">要素数</param>
        </member>
        <member name="M:GSLNET.Polynomial.Evaluate(GSLNET.Complex[],GSLNET.Complex!System.Runtime.CompilerServices.IsByValue)">
            <summary>複素変数zの複素数係数の多項式の値を計算する</summary>
            <param name="coef">複素数係数配列</param>
            <param name="z">複素変数</param>
            <returns>多項式の値</returns>
        </member>
        <member name="M:GSLNET.Polynomial.Evaluate(System.Double[],GSLNET.Complex!System.Runtime.CompilerServices.IsByValue)">
            <summary>複素変数zの実数係数の多項式の値を計算する</summary>
            <param name="coef">実数係数配列</param>
            <param name="z">複素変数</param>
            <returns>多項式の値</returns>
        </member>
        <member name="M:GSLNET.Polynomial.Evaluate(System.Double[],System.Double)">
            <summary>実数変数xの実数係数の多項式の値を計算する</summary>
            <param name="coef">実数係数配列</param>
            <param name="x">実数変数</param>
            <returns>多項式の値</returns>
        </member>
        <member name="M:GSLNET.Polynomial.Solve(System.Double[],GSLNET.Complex[]@)">
            <summary>多項式の解を計算する</summary>
            <param name="coef">実数係数配列</param>
            <param name="roots">解の配列</param>
            <returns>求根が成功したか否か</returns>
        </member>
        <member name="M:GSLNET.Polynomial.#ctor(System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="order">多項式の次数</param>
        </member>
        <member name="M:GSLNET.Polynomial.Dispose">
            <summary>デコンストラクタ</summary>
        </member>
        <member name="M:GSLNET.Complex.Polar(System.Double,System.Double)">
            <summary>極座標系での座標値を与えて複素数を作成する</summary>
            <param name="r">極座標系でのr</param>
            <param name="theta">極座標系でのtheta</param>
            <returns>複素数オブジェクト</returns>
        </member>
        <member name="M:GSLNET.Complex.Rect(System.Double,System.Double)">
            <summary>直交座標系での座標値を与えて複素数を作成する</summary>
            <param name="x">直交座標系でのx</param>
            <param name="y">直交座標系でのy</param>
            <returns>複素数オブジェクト</returns>
        </member>
        <member name="P:GSLNET.Complex.ImaginaryPart">
            <summary>虚部を設定・取得する</summary>
        </member>
        <member name="P:GSLNET.Complex.RealPart">
            <summary>実部を設定・取得する</summary>
        </member>
        <member name="M:GSLNET.Complex.Dispose">
            <summary>デコンストラクタ</summary>
        </member>
        <member name="M:GSLNET.Complex.#ctor">
            <summary>コンストラクタ</summary>
        </member>
        <member name="M:GSLNET.Permutation.Prev">
            <summary>辞書順で前の置換に戻る</summary>
            <returns>前の置換がある場合は真</returns>
        </member>
        <member name="M:GSLNET.Permutation.Next">
            <summary>辞書順で次の置換に進む</summary>
            <returns>次の置換がある場合は真</returns>
        </member>
        <member name="M:GSLNET.Permutation.Inverse(GSLNET.Permutation!System.Runtime.CompilerServices.IsByValue)">
            <summary>逆置換を計算してinvに設定する</summary>
            <param name="inv">逆置換</param>
        </member>
        <member name="M:GSLNET.Permutation.Reverse">
            <summary>要素を逆にする</summary>
        </member>
        <member name="M:GSLNET.Permutation.Swap(System.UInt32,System.UInt32)">
            <summary>要素を入れ替える</summary>
            <param name="i">要素1</param>
            <param name="j">要素2</param>
        </member>
        <member name="M:GSLNET.Permutation.GetValue(System.UInt32)">
            <summary>要素を取得する</summary>
            <param name="index">要素番号</param>
            <returns>要素の値</returns>
        </member>
        <member name="M:GSLNET.Permutation.Copy(GSLNET.Permutation!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>置換ベクトルをコピーする</summary>
            <param name="target">コピー先の置換ベクトル（初期化されている必要がある）</param>
        </member>
        <member name="M:GSLNET.Permutation.Initialize">
            <summary>恒等置換となるように初期化する</summary>
        </member>
        <member name="P:GSLNET.Permutation.Size">
            <summary>置換ベクトルのサイズを取得する</summary>
        </member>
        <member name="M:GSLNET.Permutation.#ctor(System.UInt32,System.Boolean)">
            <summary>コンストラクタ</summary>
            <param name="n">置換ベクトルの次元</param>
            <param name="initVector">恒等置換となるように初期化するか</param>
        </member>
        <member name="M:GSLNET.Permutation.#ctor(System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="n">置換ベクトルの次元</param>
        </member>
        <member name="T:GSLNET.Permutation">
            <summary>置換ベクトルクラス</summary>
        </member>
        <member name="M:GSLNET.SurfaceInterpolation.Evaluate(System.Double,System.Double)">
            <summary>補間関数値を計算する</summary>
            <param name="x">Xの値</param>
            <param name="y">Yの値</param>
        </member>
        <member name="M:GSLNET.SurfaceInterpolation.Initialize(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>初期化する</summary>
            <param name="x">Xの値配列</param>
            <param name="y">Yの値配列</param>
            <param name="z">Zの値配列</param>
        </member>
        <member name="P:GSLNET.SurfaceInterpolation.DataNumberY">
            <summary>Y方向のデータ数を設定・取得する</summary>
        </member>
        <member name="P:GSLNET.SurfaceInterpolation.DataNumberX">
            <summary>X方向のデータ数を設定・取得する</summary>
        </member>
        <member name="M:GSLNET.Interpolation.EvaluateIntegral(System.Double,System.Double)">
            <summary>補間関数の積分値を計算する</summary>
            <param name="x1">積分区間開始位置</param>
            <param name="x2">積分区間終了位置</param>
        </member>
        <member name="M:GSLNET.Interpolation.EvaluateDerivative2(System.Double)">
            <summary>補間関数の二階微分値を計算する</summary>
            <param name="x">補間位置</param>
        </member>
        <member name="M:GSLNET.Interpolation.EvaluateDerivative(System.Double)">
            <summary>補間関数の微分値を計算する</summary>
            <param name="x">補間位置</param>
        </member>
        <member name="M:GSLNET.Interpolation.Evaluate(System.Double)">
            <summary>補間関数値を計算する</summary>
            <param name="x">補間位置</param>
        </member>
        <member name="M:GSLNET.Interpolation.Initialize(System.Double[],System.Double[])">
            <summary>初期化する</summary>
            <param name="x">Xの値配列</param>
            <param name="y">Yの値配列</param>
        </member>
        <member name="M:GSLNET.Interpolation.#ctor(System.UInt32,GSLNET.Interpolation.Method)">
            <summary>コンストラクタ</summary>
            <param name="size">データ数</param>
            <param name="method">補間手法</param>
        </member>
        <member name="P:GSLNET.Interpolation.DataNumber">
            <summary>データ数を設定・取得する</summary>
        </member>
        <member name="F:GSLNET.Interpolation.Method.Akima_Periodic">
            <summary>周期的境界条件での秋間スプライン</summary>
        </member>
        <member name="F:GSLNET.Interpolation.Method.Akima">
            <summary>自然境界での秋間スプライン</summary>
        </member>
        <member name="F:GSLNET.Interpolation.Method.CSpline_Periodic">
            <summary>周期的境界の三次スプライン</summary>
        </member>
        <member name="F:GSLNET.Interpolation.Method.CSpline">
            <summary>自然境界での三次スプライン</summary>
        </member>
        <member name="F:GSLNET.Interpolation.Method.Polynomial">
            <summary>多項式補間</summary>
        </member>
        <member name="F:GSLNET.Interpolation.Method.Linear">
            <summary>線形補間</summary>
        </member>
        <member name="T:GSLNET.Interpolation.Method">
            <summary>保管法の種類</summary>
        </member>
        <member name="M:GSLNET.Matrix.ToArray">
            <summary>配列に変換する</summary>
            <returns>配列</returns>
        </member>
        <member name="M:GSLNET.Matrix.MakeUnitMatrix">
            <summary>単位行列にする</summary>
        </member>
        <member name="M:GSLNET.Matrix.InitializeValue(System.Double)">
            <summary>すべての行列成分の値を初期化する</summary>
            <param name="value">初期化する値</param>
        </member>
        <member name="M:GSLNET.Matrix.SubtractValue(System.UInt32,System.UInt32,System.Double)">
            <summary>行列成分から減算する</summary>
            <param name="columnIndex">行番号</param>
            <param name="rowIndex">列番号</param>
            <param name="value">行列成分(columnIndex, rowIndex)から減算する値</param>
        </member>
        <member name="M:GSLNET.Matrix.AddValue(System.UInt32,System.UInt32,System.Double)">
            <summary>行列成分に加算する</summary>
            <param name="columnIndex">行番号</param>
            <param name="rowIndex">列番号</param>
            <param name="value">行列成分(columnIndex, rowIndex)に加算する値</param>
        </member>
        <member name="M:GSLNET.Matrix.SetValue(System.UInt32,System.UInt32,System.Double)">
            <summary>行列成分を設定する</summary>
            <param name="columnIndex">行番号</param>
            <param name="rowIndex">列番号</param>
            <param name="value">行列成分(columnIndex, rowIndex)の値</param>
        </member>
        <member name="M:GSLNET.Matrix.GetValue(System.UInt32,System.UInt32)">
            <summary>行列成分を取得する</summary>
            <param name="columnIndex">行番号</param>
            <param name="rowIndex">列番号</param>
            <returns>行列成分(rowIndex, columnIndex)の値</returns>
        </member>
        <member name="P:GSLNET.Matrix.Columns">
            <summary>行数を取得する</summary>
        </member>
        <member name="P:GSLNET.Matrix.Rows">
            <summary>列数を取得する</summary>
        </member>
        <member name="M:GSLNET.Matrix.#ctor(System.UInt32,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="columnNumber">列数</param>
            <param name="rowNumber">行数</param>
        </member>
        <member name="M:GSLNET.Multifit.GetResidualError">
            <summary>残差を取得する</summary>
            <returns>残差</returns>
            <summary>残差を取得する</summary>
        </member>
        <member name="M:GSLNET.Multifit.Solve(GSLNET.GSLFunctions.DArrayToDArray,System.Double[]@,System.Double,System.Int32,System.Int32@)">
            <summary>反復計算によってパラメータを最適化する</summary>
            <param name="initialX">探索開始点</param>
            <param name="epsabs">絶対誤差</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="iterNum">反復回数</param>
            <returns>エラーコード</returns>
            <remarks>ステップ幅と探索点を、絶対誤差および相対誤差を使って比較し、収束を判定する</remarks>
        </member>
        <member name="M:GSLNET.Multifit.Solve(GSLNET.GSLFunctions.DArrayToDArray,System.Double[]@,System.Double,System.Double,System.Int32,System.Int32@)">
            <summary>反復計算によってパラメータを最適化する</summary>
            <param name="initialX">探索開始点</param>
            <param name="epsabs">絶対誤差</param>
            <param name="epsrel">相対誤差</param>
            <param name="maxIteration">最大反復回数</param>
            <param name="iterNum">反復回数</param>
            <returns>エラーコード</returns>
            <remarks>ステップ幅と探索点を、絶対誤差および相対誤差を使って比較し、収束を判定する</remarks>
        </member>
        <member name="M:GSLNET.Multifit.#ctor(GSLNET.Multifit.SolverType,System.UInt32,System.UInt32)">
            <summary>コンストラクタ</summary>
            <param name="sType">非線形最小二乗法の種類</param>
            <param name="dataNumber">データ点数</param>
            <param name="parameterNumber">パラメータ数</param>
        </member>
        <member name="F:GSLNET.Multifit.SolverType.LevenbergMarquardt">
            <summary>Levenberg-Marquardt法</summary>
        </member>
        <member name="F:GSLNET.Multifit.SolverType.LevenbergMarquardtWithScaling">
            <summary>スケーリング付のLevenberg-Marquardt法</summary>
        </member>
        <member name="T:GSLNET.Multifit.SolverType">
            <summary>非線形最小二乗法の種類</summary>
        </member>
        <member name="T:GSLNET.Multifit">
            <summary>非線形最小二乗法ソルバークラス</summary>
        </member>
        <member name="F:GSLNET.Jacobian.Delta">
            <summary>ヤコビ行列計算用有限差分値を設定・取得する</summary>
        </member>
        <member name="M:GSLNET.Jacobian.Calculate(GSLNET.GSLFunctions.TDArrayToDArray,System.Double,System.Double[],System.Double[][]@,System.Double[]@)">
            <summary>ヤコビ行列を計算する</summary>
            <param name="fnc">出力ベクトル（m次元）計算関数</param>
            <param name="fnc">時刻</param>
            <param name="inputs">入力ベクトル（n次元）</param>
            <param name="jacobian">ヤコビ行列（n×m次元）</param>
            <param name="dydt">時間に対する出力微分ベクトル</param>
        </member>
        <member name="M:GSLNET.Jacobian.Calculate(GSLNET.GSLFunctions.DArrayToDArray,System.Double[],System.Double[][]@)">
            <summary>ヤコビ行列を計算する</summary>
            <param name="fnc">出力ベクトル（m次元）計算関数</param>
            <param name="inputs">入力ベクトル（n次元）</param>
            <param name="jacobian">ヤコビ行列（n×m次元）</param>
        </member>
        <member name="T:GSLNET.GSLFunctions.DToD">
            <summary>実数値入力から実数値出力を計算する関数</summary>
            <param name="input">実数値入力</param>
            <returns>実数値出力</returns>
        </member>
        <member name="T:GSLNET.GSLFunctions.TDArray">
            <summary>時刻と入力ベクトルを与える関数</summary>
            <param name="t">時刻</param>
            <param name="inputs">入力ベクトル</param>
        </member>
        <member name="T:GSLNET.GSLFunctions.TDArrayToDArray">
            <summary>時刻と入力ベクトルから出力ベクトルを計算する関数</summary>
            <param name="t">時刻</param>
            <param name="inputs">入力ベクトル</param>
            <param name="outputs">出力ベクトル</param>
        </member>
        <member name="T:GSLNET.GSLFunctions.DArrayToDArray">
            <summary>入力ベクトルから出力ベクトルを計算する関数</summary>
            <param name="inputs">入力ベクトル</param>
            <param name="outputs">出力ベクトル</param>
        </member>
        <member name="T:GSLNET.ErrorNumber">
            <summary>GSLNETエラーコード</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EOF">
            <summary>end of file</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ETOLG">
            <summary>cannot reach the specified tolerance in gradient</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ETOLX">
            <summary>cannot reach the specified tolerance in X</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ETOLF">
            <summary>cannot reach the specified tolerance in F</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ENOPROGJ">
            <summary>jacobian evaluations are not improving the solution</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ENOPROG">
            <summary>iteration is not making progress towards solution</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ETABLE">
            <summary>table limit exceeded</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ECACHE">
            <summary>cache limit exceeded</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EUNIMPL">
            <summary>requested feature not (yet) implemented</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EUNSUP">
            <summary>requested feature is not supported by the hardware</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EDIVERGE">
            <summary>integral or series is divergent</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ESING">
            <summary>apparent singularity detected</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ENOTSQR">
            <summary>matrix not square</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EBADLEN">
            <summary>matrix, vector lengths are not conformant</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EROUND">
            <summary>failed because of roundoff error</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ELOSS">
            <summary>loss of accuracy</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EOVRFLW">
            <summary>overflow</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EUNDRFLW">
            <summary>underflow</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ETOL">
            <summary>failed to reach the specified tolerance</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EBADTOL">
            <summary>user specified an invalid tolerance</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EZERODIV">
            <summary>tried to divide by zero</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EMAXITER">
            <summary>exceeded max number of iterations</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ERUNAWAY">
            <summary>iterative process is out of control</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EBADFUNC">
            <summary>problem with user-supplied function</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ENOMEM">
            <summary>malloc failed</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ESANITY">
            <summary>sanity check failed - shouldn't happen</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EFACTOR">
            <summary>factorization failed</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EFAILED">
            <summary>generic failure</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EINVAL">
            <summary>invalid argument supplied by user</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EFAULT">
            <summary>invalid pointer</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_ERANGE">
            <summary>output range error, e.g. exp(1e100)</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_EDOM">
            <summary>input domain error, e.g sqrt(-1)</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_CONTINUE">
            <summary>iteration has not converged</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_FAILURE">
            <summary>失敗</summary>
        </member>
        <member name="F:GSLNET.ErrorNumber.GSL_SUCCESS">
            <summary>成功</summary>
        </member>
    </members>
</doc>